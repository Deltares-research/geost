{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Retrieving and analysing BRO soil cores \n",
    "\n",
    "In this example, we will download soil cores (BRO BHR-P objects) and calculate the total\n",
    "thickness of sand, clay, silt and peat layers for each or the boreholes.\n",
    "\n",
    "First we import GeoST and retrieve soil cores from the area of Landgoed Oostbroek\n",
    "(located between Utrecht Science Park and Zeist). GeoST directly connects to the BRO\n",
    "REST-API service. This allows the user to download BRO objects from a spatial \n",
    "query and apply GeoST functionality to the loaded objects. In this case we will use \n",
    "a bounding box:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import geost\n",
    "\n",
    "bhrp_cores = geost.bro_api_read(\"BHR-P\", bbox=(141_000, 455_200, 142_500, 456_000)) # xmin, ymin, xmax, ymax\n",
    "\n",
    "print(bhrp_cores)\n",
    "print('\\nThe header looks like this:')\n",
    "bhrp_cores.header.gdf.head()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "BRO objects come in the Rijksdriehoek coordinate reference system by default (EPSG: 28992),\n",
    "but the example project requires us to work in UTM 31N coordinates (EPSG: 32631). Hence we \n",
    "convert the CRS and check the result:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "bhrp_cores.change_horizontal_reference(32631) # This is an in-place operation\n",
    "\n",
    "print(bhrp_cores.horizontal_reference)\n",
    "bhrp_cores.header.gdf.head()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Furthermore, we'd only like to work with boreholes that have a minimum length of 1.5 m"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "bhrp_cores = bhrp_cores.select_by_length(1.5) # Not an in-place operation, so assign to new or overwrite existing variable!\n",
    "\n",
    "print(bhrp_cores)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "It looks like we ditched only two boreholes that were too short.\n",
    "\n",
    "Next, we need to get the main lithology (Zand, Leem, Klei or Veen = Sand, Silt, Clay or Peat) \n",
    "of each described layer in our collection of boreholes. We can use the \"standard_name\" column\n",
    "in the data, which is a lithological description including an indication of admixture:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "bhrp_cores.data[\"standardSoilName\"].unique()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Since we are only interested in the main lithology we need to simplify the names. There \n",
    "is no method for this provided by GeoST, so we will have to create our own. Luckily, GeoST\n",
    "is built on Pandas, which means that you can easily apply your own logic if\n",
    "built-in GeoST methods don't get you where you want. In this case, we will use a string method of a Pandas Series to use a regex (i.e. regular expression) which extracts the main lithology. This will reduce e.g. \"matigSiltigeKlei\" to \"Klei\"."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "bhrp_cores.data[\"lithology\"] = bhrp_cores.data[\"standardSoilName\"].str.extract(\n",
    "    r'(Klei|Zand|Leem|Veen)$', expand=False # Find one of these words at the end of the standardSoilName\n",
    ")\n",
    "\n",
    "# Check and show that it worked:\n",
    "bhrp_cores.data[\"lithology\"].unique()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Now we can proceed to compute the total thickness of our main lithologies by applying\n",
    "the built-in method \"get_cumulative_thickness\" on our just created \"main_lithology\" column."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# By including the \"include_in_header=True\" argument, the result will be added in-place\n",
    "# to the header table of the BoreholeCollection. If False, the function will only return\n",
    "# a Pandas dataframe with the results.\n",
    "bhrp_cores.get_cumulative_thickness(\n",
    "    \"lithology\",\n",
    "    [\"Klei\", \"Zand\", \"Leem\", \"Veen\"],\n",
    "    include_in_header=True\n",
    ")\n",
    "\n",
    "# Check if the new columns are present and correct in the header table\n",
    "bhrp_cores.header.gdf.head()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "For the purpose of this example we will quickly plot the results on a map below. Hover your mouse\n",
    "over the points to display header information, including the layer thicknesses that we just added.\n",
    "From this point you would normally export the data or continue with further data analyses."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "bhrp_cores.header.gdf.explore(style_kwds=dict(color=\"red\", weight=6))"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "default",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.13.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
